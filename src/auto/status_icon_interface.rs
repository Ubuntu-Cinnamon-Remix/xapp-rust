// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;

glib::wrapper! {
    #[doc(alias = "XAppStatusIconInterface")]
    pub struct StatusIconInterface(Interface<ffi::XAppStatusIconInterface, ffi::XAppStatusIconInterfaceIface>);

    match fn {
        type_ => || ffi::xapp_status_icon_interface_get_type(),
    }
}

impl StatusIconInterface {
        pub const NONE: Option<&'static StatusIconInterface> = None;
    

    #[doc(alias = "xapp_status_icon_interface_interface_info")]
    pub fn interface_info() -> Option<gio::DBusInterfaceInfo> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_interface_info())
        }
    }

    //#[doc(alias = "xapp_status_icon_interface_override_properties")]
    //pub fn override_properties(klass: /*Ignored*/&mut glib::ObjectClass, property_id_begin: u32) -> u32 {
    //    unsafe { TODO: call ffi:xapp_status_icon_interface_override_properties() }
    //}
}

pub trait StatusIconInterfaceExt: 'static {
    #[doc(alias = "xapp_status_icon_interface_call_button_press")]
    fn call_button_press<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P);

    
    fn call_button_press_future(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[doc(alias = "xapp_status_icon_interface_call_button_press_sync")]
    fn call_button_press_sync(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error>;

    #[doc(alias = "xapp_status_icon_interface_call_button_release")]
    fn call_button_release<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P);

    
    fn call_button_release_future(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[doc(alias = "xapp_status_icon_interface_call_button_release_sync")]
    fn call_button_release_sync(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error>;

    #[doc(alias = "xapp_status_icon_interface_call_scroll")]
    fn call_scroll<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P);

    
    fn call_scroll_future(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[doc(alias = "xapp_status_icon_interface_call_scroll_sync")]
    fn call_scroll_sync(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error>;

    #[doc(alias = "xapp_status_icon_interface_complete_button_press")]
    fn complete_button_press(&self, invocation: &gio::DBusMethodInvocation);

    #[doc(alias = "xapp_status_icon_interface_complete_button_release")]
    fn complete_button_release(&self, invocation: &gio::DBusMethodInvocation);

    #[doc(alias = "xapp_status_icon_interface_complete_scroll")]
    fn complete_scroll(&self, invocation: &gio::DBusMethodInvocation);

    #[doc(alias = "xapp_status_icon_interface_dup_icon_name")]
    fn dup_icon_name(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_dup_label")]
    fn dup_label(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_dup_metadata")]
    fn dup_metadata(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_dup_name")]
    fn dup_name(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_dup_tooltip_text")]
    fn dup_tooltip_text(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_icon_name")]
    #[doc(alias = "get_icon_name")]
    fn icon_name(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_icon_size")]
    #[doc(alias = "get_icon_size")]
    fn icon_size(&self) -> i32;

    #[doc(alias = "xapp_status_icon_interface_get_label")]
    #[doc(alias = "get_label")]
    fn label(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_metadata")]
    #[doc(alias = "get_metadata")]
    fn metadata(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_primary_menu_is_open")]
    #[doc(alias = "get_primary_menu_is_open")]
    fn is_primary_menu_is_open(&self) -> bool;

    #[doc(alias = "xapp_status_icon_interface_get_secondary_menu_is_open")]
    #[doc(alias = "get_secondary_menu_is_open")]
    fn is_secondary_menu_is_open(&self) -> bool;

    #[doc(alias = "xapp_status_icon_interface_get_tooltip_text")]
    #[doc(alias = "get_tooltip_text")]
    fn tooltip_text(&self) -> Option<glib::GString>;

    #[doc(alias = "xapp_status_icon_interface_get_visible")]
    #[doc(alias = "get_visible")]
    fn is_visible(&self) -> bool;

    #[doc(alias = "xapp_status_icon_interface_set_icon_name")]
    fn set_icon_name(&self, value: &str);

    #[doc(alias = "xapp_status_icon_interface_set_icon_size")]
    fn set_icon_size(&self, value: i32);

    #[doc(alias = "xapp_status_icon_interface_set_label")]
    fn set_label(&self, value: &str);

    #[doc(alias = "xapp_status_icon_interface_set_metadata")]
    fn set_metadata(&self, value: &str);

    #[doc(alias = "xapp_status_icon_interface_set_name")]
    fn set_name(&self, value: &str);

    #[doc(alias = "xapp_status_icon_interface_set_primary_menu_is_open")]
    fn set_primary_menu_is_open(&self, value: bool);

    #[doc(alias = "xapp_status_icon_interface_set_secondary_menu_is_open")]
    fn set_secondary_menu_is_open(&self, value: bool);

    #[doc(alias = "xapp_status_icon_interface_set_tooltip_text")]
    fn set_tooltip_text(&self, value: &str);

    #[doc(alias = "xapp_status_icon_interface_set_visible")]
    fn set_visible(&self, value: bool);

    #[doc(alias = "handle-button-press")]
    fn connect_handle_button_press<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "handle-button-release")]
    fn connect_handle_button_release<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "handle-scroll")]
    fn connect_handle_scroll<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "icon-name")]
    fn connect_icon_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "icon-size")]
    fn connect_icon_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "label")]
    fn connect_label_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "metadata")]
    fn connect_metadata_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "name")]
    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "primary-menu-is-open")]
    fn connect_primary_menu_is_open_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "secondary-menu-is-open")]
    fn connect_secondary_menu_is_open_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "tooltip-text")]
    fn connect_tooltip_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "visible")]
    fn connect_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<StatusIconInterface>> StatusIconInterfaceExt for O {
    fn call_button_press<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn call_button_press_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let _ = ffi::xapp_status_icon_interface_call_button_press_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = call_button_press_trampoline::<P>;
        unsafe {
            ffi::xapp_status_icon_interface_call_button_press(self.as_ref().to_glib_none().0, arg_x, arg_y, arg_button, arg_time, arg_panel_position, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn call_button_press_future(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.call_button_press(
                arg_x,
                arg_y,
                arg_button,
                arg_time,
                arg_panel_position,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn call_button_press_sync(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::xapp_status_icon_interface_call_button_press_sync(self.as_ref().to_glib_none().0, arg_x, arg_y, arg_button, arg_time, arg_panel_position, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    fn call_button_release<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn call_button_release_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let _ = ffi::xapp_status_icon_interface_call_button_release_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = call_button_release_trampoline::<P>;
        unsafe {
            ffi::xapp_status_icon_interface_call_button_release(self.as_ref().to_glib_none().0, arg_x, arg_y, arg_button, arg_time, arg_panel_position, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn call_button_release_future(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.call_button_release(
                arg_x,
                arg_y,
                arg_button,
                arg_time,
                arg_panel_position,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn call_button_release_sync(&self, arg_x: i32, arg_y: i32, arg_button: u32, arg_time: u32, arg_panel_position: i32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::xapp_status_icon_interface_call_button_release_sync(self.as_ref().to_glib_none().0, arg_x, arg_y, arg_button, arg_time, arg_panel_position, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    fn call_scroll<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn call_scroll_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let _ = ffi::xapp_status_icon_interface_call_scroll_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = call_scroll_trampoline::<P>;
        unsafe {
            ffi::xapp_status_icon_interface_call_scroll(self.as_ref().to_glib_none().0, arg_delta, arg_orientation, arg_time, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn call_scroll_future(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.call_scroll(
                arg_delta,
                arg_orientation,
                arg_time,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn call_scroll_sync(&self, arg_delta: i32, arg_orientation: i32, arg_time: u32, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let is_ok = ffi::xapp_status_icon_interface_call_scroll_sync(self.as_ref().to_glib_none().0, arg_delta, arg_orientation, arg_time, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    fn complete_button_press(&self, invocation: &gio::DBusMethodInvocation) {
        unsafe {
            ffi::xapp_status_icon_interface_complete_button_press(self.as_ref().to_glib_none().0, invocation.to_glib_full());
        }
    }

    fn complete_button_release(&self, invocation: &gio::DBusMethodInvocation) {
        unsafe {
            ffi::xapp_status_icon_interface_complete_button_release(self.as_ref().to_glib_none().0, invocation.to_glib_full());
        }
    }

    fn complete_scroll(&self, invocation: &gio::DBusMethodInvocation) {
        unsafe {
            ffi::xapp_status_icon_interface_complete_scroll(self.as_ref().to_glib_none().0, invocation.to_glib_full());
        }
    }

    fn dup_icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::xapp_status_icon_interface_dup_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    fn dup_label(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::xapp_status_icon_interface_dup_label(self.as_ref().to_glib_none().0))
        }
    }

    fn dup_metadata(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::xapp_status_icon_interface_dup_metadata(self.as_ref().to_glib_none().0))
        }
    }

    fn dup_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::xapp_status_icon_interface_dup_name(self.as_ref().to_glib_none().0))
        }
    }

    fn dup_tooltip_text(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::xapp_status_icon_interface_dup_tooltip_text(self.as_ref().to_glib_none().0))
        }
    }

    fn icon_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_get_icon_name(self.as_ref().to_glib_none().0))
        }
    }

    fn icon_size(&self) -> i32 {
        unsafe {
            ffi::xapp_status_icon_interface_get_icon_size(self.as_ref().to_glib_none().0)
        }
    }

    fn label(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_get_label(self.as_ref().to_glib_none().0))
        }
    }

    fn metadata(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_get_metadata(self.as_ref().to_glib_none().0))
        }
    }

    fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_get_name(self.as_ref().to_glib_none().0))
        }
    }

    fn is_primary_menu_is_open(&self) -> bool {
        unsafe {
            from_glib(ffi::xapp_status_icon_interface_get_primary_menu_is_open(self.as_ref().to_glib_none().0))
        }
    }

    fn is_secondary_menu_is_open(&self) -> bool {
        unsafe {
            from_glib(ffi::xapp_status_icon_interface_get_secondary_menu_is_open(self.as_ref().to_glib_none().0))
        }
    }

    fn tooltip_text(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::xapp_status_icon_interface_get_tooltip_text(self.as_ref().to_glib_none().0))
        }
    }

    fn is_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::xapp_status_icon_interface_get_visible(self.as_ref().to_glib_none().0))
        }
    }

    fn set_icon_name(&self, value: &str) {
        unsafe {
            ffi::xapp_status_icon_interface_set_icon_name(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn set_icon_size(&self, value: i32) {
        unsafe {
            ffi::xapp_status_icon_interface_set_icon_size(self.as_ref().to_glib_none().0, value);
        }
    }

    fn set_label(&self, value: &str) {
        unsafe {
            ffi::xapp_status_icon_interface_set_label(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn set_metadata(&self, value: &str) {
        unsafe {
            ffi::xapp_status_icon_interface_set_metadata(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn set_name(&self, value: &str) {
        unsafe {
            ffi::xapp_status_icon_interface_set_name(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn set_primary_menu_is_open(&self, value: bool) {
        unsafe {
            ffi::xapp_status_icon_interface_set_primary_menu_is_open(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn set_secondary_menu_is_open(&self, value: bool) {
        unsafe {
            ffi::xapp_status_icon_interface_set_secondary_menu_is_open(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn set_tooltip_text(&self, value: &str) {
        unsafe {
            ffi::xapp_status_icon_interface_set_tooltip_text(self.as_ref().to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn set_visible(&self, value: bool) {
        unsafe {
            ffi::xapp_status_icon_interface_set_visible(self.as_ref().to_glib_none().0, value.into_glib());
        }
    }

    fn connect_handle_button_press<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn handle_button_press_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(this: *mut ffi::XAppStatusIconInterface, invocation: *mut gio::ffi::GDBusMethodInvocation, arg_x: libc::c_int, arg_y: libc::c_int, arg_button: libc::c_uint, arg_time: libc::c_uint, arg_panel_position: libc::c_int, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(invocation), arg_x, arg_y, arg_button, arg_time, arg_panel_position).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"handle-button-press\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(handle_button_press_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_handle_button_release<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn handle_button_release_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P, &gio::DBusMethodInvocation, i32, i32, u32, u32, i32) -> bool + 'static>(this: *mut ffi::XAppStatusIconInterface, invocation: *mut gio::ffi::GDBusMethodInvocation, arg_x: libc::c_int, arg_y: libc::c_int, arg_button: libc::c_uint, arg_time: libc::c_uint, arg_panel_position: libc::c_int, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(invocation), arg_x, arg_y, arg_button, arg_time, arg_panel_position).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"handle-button-release\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(handle_button_release_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_handle_scroll<F: Fn(&Self, &gio::DBusMethodInvocation, i32, i32, u32) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn handle_scroll_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P, &gio::DBusMethodInvocation, i32, i32, u32) -> bool + 'static>(this: *mut ffi::XAppStatusIconInterface, invocation: *mut gio::ffi::GDBusMethodInvocation, arg_delta: libc::c_int, arg_orientation: libc::c_int, arg_time: libc::c_uint, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(invocation), arg_delta, arg_orientation, arg_time).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"handle-scroll\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(handle_scroll_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_icon_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_icon_name_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::icon-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_icon_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_icon_size_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_icon_size_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::icon-size\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_icon_size_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_label_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_label_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::label\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_label_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_metadata_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_metadata_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::metadata\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_metadata_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_name_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_primary_menu_is_open_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_primary_menu_is_open_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::primary-menu-is-open\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_primary_menu_is_open_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_secondary_menu_is_open_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_secondary_menu_is_open_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::secondary-menu-is-open\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_secondary_menu_is_open_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_tooltip_text_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tooltip_text_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tooltip-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_tooltip_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_visible_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_visible_trampoline<P: IsA<StatusIconInterface>, F: Fn(&P) + 'static>(this: *mut ffi::XAppStatusIconInterface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(StatusIconInterface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::visible\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_visible_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for StatusIconInterface {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("StatusIconInterface")
    }
}
